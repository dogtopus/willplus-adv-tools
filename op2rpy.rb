#!/usr/bin/env ruby
# (partially) converts RIOASM to Ren'Py script 

require_relative 'opcode'
require_relative 'op2rpy_settings_enum'
require_relative 'op2rpy_settings'
require_relative 'bb'
include O2RSettingsEnum
include O2RSettings

module RIOASMTranslator
    class WillPlusDisplayable
        def initialize(name, absxpos=0, absypos=0, force_topleft_anchor=false)
            @name = name
            @pos_init = [absxpos, absypos]
            @pos = [absxpos, absypos]
            @alpha = 1.0
            @total_duration = 0.0
            @key_frames = []
            @force_topleft_anchor = force_topleft_anchor
            @pending_for_removal = false
        end

        def add_key_frame(delta_x, delta_y, duration, alpha)
            @pos[0] += delta_x
            @pos[1] += delta_y
            # TODO Untested. What's the unit value?
            @alpha += alpha / 255.0
            duration_s = duration / 1000.0
            @total_duration += duration_s
            # Calculate absolute positions on screen
            frame_abs = {}
            frame_abs[:duration] = duration_s
            frame_abs[:xpos] = @pos[0] / 800.0 unless delta_x == 0
            frame_abs[:ypos] = @pos[1] / 600.0 unless delta_y == 0
            frame_abs[:alpha] = @alpha unless alpha == 0
            @key_frames << frame_abs
        end

        def to_renpy_atl()
            xpos_init_f = @pos_init[0] / 800.0
            ypos_init_f = @pos_init[1] / 600.0
            result = []
            # Write initial position
            result << 'anchor (0, 0)' if @force_topleft_anchor
            if @pos_init[0] == 0 or @pos_init[1] == 0
                result << "xpos #{xpos_init_f}" unless @pos_init[0] == 0
                result << "ypos #{ypos_init_f}" unless @pos_init[1] == 0
            else
                result << "pos (#{xpos_init_f}, #{ypos_init_f})"
            end
            @key_frames.each do |f|
                # All nil => pause
                if f[:xpos].nil? and f[:ypos].nil? and f[:alpha].nil?
                    result << "pause #{f[:duration]}"
                # xpos or ypos is nil => split xpos and ypos and add alpha if necessary
                elsif f[:xpos].nil? or f[:ypos].nil?
                    entries = []
                    entries << "linear #{f[:duration]}"
                    entries << "xpos #{f[:xpos]}" unless f[:xpos].nil?
                    entries << "ypos #{f[:ypos]}" unless f[:ypos].nil?
                    entries << "alpha #{f[:alpha]}" unless f[:alpha].nil?
                    result << entries.join(' ')
                # xpos and ypos are both not nil => squash them as pos and add alpha if necessary
                else
                    entries = []
                    entries << "linear #{f[:duration]} pos (#{f[:xpos]}, #{f[:ypos]})"
                    entries << "alpha #{f[:alpha]}" unless f[:alpha].nil?
                    result << entries.join(' ')
                end
            end
            return result
        end
        attr_reader :total_duration, :pos_init, :pos, :alpha, :key_frames, :name
        attr_accessor :pending_for_removal
    end


    def translate(scr_name, scr)
        @rpy = RpyGenerator.new
        @gfx = {:bg => nil, :bg_redraw => false, :fg => [], :fg_redraw => false, :obj => nil, :obj_redraw => false, :em => nil}
        @say_for_menu = nil
        @index = 0
        @offset = 0
        @code_block_ends_at = []
        @jmp_trigger = []
        @scr = scr
        @scr_inst_by_offset = {}
        @scr_name = scr_name
        @cfg = RIOControlFlow.new(scr)
        @rpy.add_comment("Generated by op2rpy, edit with caution.")
        @rpy.add_cmd("label RIO_#{scr_name}:")
        @rpy.begin_block()
        @scr.each_with_index { |cmd, entry| @scr_inst_by_offset[cmd[0]] = entry }
        @scr.each_with_index do |cmd, entry|
            @offset = cmd[0]
            _check_code_block(cmd[0])
            _check_absjump_tag(cmd[0])
            _queue_say_for_menu_if_necessary(cmd, @scr[entry+1..-1]) if MOVE_PREVIOUS_SAY_INTO_MENU
            if respond_to?("op_#{cmd[1]}")
                @rpy.add_comment("[cmd] #{_generate_cmd_disasm(cmd)}") if FORCE_INCLUDE_DISASM
                send("op_#{cmd[1]}", *cmd[2..-1])
            else
                @rpy.add_comment("[cmd:unhandled] #{_generate_cmd_disasm(cmd)}")
            end
            @index += 1
        end
        @rpy.end_block()
        return @rpy.to_s
    end

    def _generate_cmd_disasm(cmd)
        return "0x#{cmd[0].to_s(16)}:#{cmd[1]}(#{cmd[2..-1].to_s.gsub(/[\[\]]/, '')})"
    end

    def _check_code_block(cur_offset)
        if @code_block_ends_at[-1] == cur_offset
            @rpy.end_block()
            @code_block_ends_at.pop()
            _check_code_block(cur_offset)
        end
    end
    
    def _check_absjump_tag(cur_offset)
        if @jmp_trigger.include?(cur_offset)
            @rpy.end_block()
            @rpy.add_cmd("label RIO_#{@scr_name}_#{cur_offset}:")
            @rpy.begin_block()
            @jmp_trigger.delete(cur_offset)
        end
    end

    def _queue_say_for_menu_if_necessary(cmd, scr_after)
        return unless cmd[1] == 'text_c' or cmd[1] == 'text_n'
        scr_after.each do |cmd_next|
            case cmd_next[1]
            # Follows by a say. Stop looking.
            when 'text_c', 'text_n'
                break
            # Follows by menu. This is what we are looking for.
            when 'option'
                # Save the say instruction for later use.
                @say_for_menu = cmd
            end
        end
    end

    def _get_flag_reference(flag_addr, on_hint)
        bank = nil
        FLAG_BANKS.each do |b|
            if flag_addr.between?(b[0], b[1])
                bank = b[2]
                break
            end
        end
        if bank.nil?
            @rpy.add_comment("[warning:_get_flag_reference] Access to unmapped flag address #{flag_addr}")
            return nil
        end
        v = FLAG_TABLE[flag_addr]
        # Check for excluded or hinted flags
        if v
            # Labeled flag or requires special care
            flag_ref = "#{bank}[#{(v[0].nil?) ? flag_addr : ("'#{v[0]}'")}]"
            if v[1] == Flag::EXCLUDE
                return nil
            elsif v[1] == Flag::HINT
                @rpy.add_comment(on_hint.call(flag_ref))
                return nil
            elsif v[1] == Flag::INCLUDE
                return flag_ref
            else
                raise 'Invalid flag inclusion policy.'
            end
        else
            # Unlabeled flag
            return "#{bank}[#{flag_addr}]"
        end
    end

    def _convert_escape_sequences(text)
        result = []
        offset = 0
        while offset < text.length
            case text[offset]
            # Backslash (\n => \n, \\ => \\, \<other> => \\<other>)
            when '\\'
                case text[offset+1]
                # Newline
                when 'n'
                    result << '\\n'
                    offset += 2
                # Escaped backslash
                when '\\'
                    result << '\\\\'
                    offset += 2
                # Unknown escaping, output with the backslash escaped. The next character will be properly escaped if necessary.
                else
                    result << '\\\\'
                    offset += 1
                end
            # Single/double quote (' " => \' \")
            when '"', "'"
                result << '\\'
                result << text[offset]
                offset += 1
            # TODO: Escape all spaces?
            # Square brackets. Not (?) used in WillPlus engine?
            when '[', ']'
                result << text[offset]
                result << text[offset]
                offset += 1
            # Curly brackets. Used by WillPlus engine as (at least) ruby text.
            when '{'
                # {<rb>:<rt>}
                m = /^{([^:{}]+):([^:{}]+)}/.match(text[offset..-1])
                # Malformed ruby text escaping. Escape the leading bracket and continue.
                if m.nil?
                    result << text[offset]
                    result << text[offset]
                    offset += 1
                else
                    result << '{rb}' if m[1].length > 1
                    result << m[1]
                    result << '{/rb}' if m[1].length > 1
                    result << '{rt}'
                    result << m[2]
                    result << '{/rt}'
                    offset += m[0].length
                end
            # This shouldn't happen when the input is properly formatted. However if it does, escape it.
            when '}'
                result << text[offset]
                result << text[offset]
                offset += 1
            # Regular text
            else
                result << text[offset]
                offset += 1
            end
        end
        return result.join()
    end

    def op_call(label)
        @rpy.add_cmd("call RIO_#{label.upcase()}")
    end

    def op_return()
        @rpy.add_cmd('return')
    end

    def op_option(*args)
        raise 'Wrong number of parameters' if (args.length % 6) != 0

        @rpy.add_cmd("menu:")
        @rpy.begin_block()
        if MOVE_PREVIOUS_SAY_INTO_MENU and (not @say_for_menu.nil?)
            raise '@say_for_menu contains instruction other than text_n or text_c' unless @say_for_menu[1] == 'text_c' or @say_for_menu[1] == 'text_n'
            send("op__option_#{@say_for_menu[1]}", *@say_for_menu[2..-1])
            @say_for_menu = nil
        end
        (args.length / 6).times do |i|
            opt = args[(i * 6)..((i + 1) * 6)]
            opt[1].encode!('utf-8', RIO_TEXT_ENCODING)
            @rpy.add_cmd("\"#{opt[1]}\":")
            @rpy.begin_block()
            @rpy.add_cmd("jump RIO_#{opt[5].upcase()}")
            @rpy.end_block()
        end
        @rpy.end_block()
    end

    # TODO flag operations
    def op_set(operator, lvar, is_flag, rside, try_boolify=false)
        if try_boolify and rside.between?(0, 1)
            rside = rside == 0 ? 'False' : 'True'
        end
        flag_ref = _get_flag_reference(lvar, ->(ref) { return "$ #{ref} #{operator} #{rside}" })
        @rpy.add_cmd("$ #{flag_ref} #{operator} #{rside}") unless flag_ref.nil?
    end

    def op_mov(lvar, is_flag, rside)
        op_set('=', lvar, is_flag, rside, try_boolify=true)
    end

    def op_add(lvar, is_flag, rside)
        op_set('+=', lvar, is_flag, rside)
    end

    def op_sub(lvar, is_flag, rside)
        op_set('-=', lvar, is_flag, rside)
    end

    def op_mul(lvar, is_flag, rside)
        op_set('*=', lvar, is_flag, rside)
    end

    def op_div(lvar, is_flag, rside)
        op_set('/=', lvar, is_flag, rside)
    end

    def op_rnd(lvar, is_flag, rside)
        flag_ref = _get_flag_reference(lvar, ->(ref) { return "$ #{ref} = renpy.random.randint(0, #{rside})" })
        # TODO double-inclusive or upper-exclusive (Python-like)?
        @rpy.add_cmd("$ #{flag_ref} = renpy.random.randint(0, #{rside})") unless flag_ref.nil?
    end

    # TODO Can we translate this to an if...else statement?
    def op_jmp_offset(offset)
        @rpy.add_cmd("jump RIO_#{@scr_name}_#{offset}")
        @jmp_trigger << offset
    end

    def op_jmp(operator, lvar, rside, rel_offset)
        flag_ref = _get_flag_reference(lvar, ->(ref) { return "if #{ref} #{operator} #{rside}: ..." })
        if flag_ref.nil?
            # Evaluate cjmp to always be false in case the flag is inaccessible.
            @rpy.add_comment("[warning:jmp] Attempt to access inaccessible flag #{lvar} in cjmp. Evaluating to false.")
            @rpy.add_cmd("if False:")
        else
            @rpy.add_cmd("if #{flag_ref} #{operator} #{rside}:")
        end
        @rpy.begin_block()
        @code_block_ends_at << (@scr[@index + 1][0] + rel_offset)
    end

    def op_jbe(lvar, rside, rel_offset)
        return op_jmp('>=', lvar, rside, rel_offset)
    end

    def op_jle(lvar, rside, rel_offset)
        return op_jmp('<=', lvar, rside, rel_offset)
    end

    def op_jbt(lvar, rside, rel_offset)
        return op_jmp('>', lvar, rside, rel_offset)
    end

    def op_jlt(lvar, rside, rel_offset)
        return op_jmp('<', lvar, rside, rel_offset)
    end

    def op_jeq(lvar, rside, rel_offset)
        return op_jmp('==', lvar, rside, rel_offset)
    end

    def op_jne(lvar, rside, rel_offset)
        return op_jmp('!=', lvar, rside, rel_offset)
    end

    def op_bg(xabspos, yabspos, arg3, arg4, arg5, bgname)
        if bgname != (@gfx[:bg].name rescue nil)
            @gfx[:bg] = WillPlusDisplayable.new(bgname, xabspos, yabspos)
            @gfx[:bg_redraw] = true
        else
            @gfx[:bg].pending_for_removal = false
        end
    end

    def op_fg(index, xabspos, yabspos, arg4, arg5, arg6, arg7, fgname)
        if fgname != (@gfx[:fg][index].name rescue nil)
            @gfx[:fg][index] = WillPlusDisplayable.new(fgname, xabspos, yabspos)
            @gfx[:fg_redraw] = true
        else
            @gfx[:fg][index].pending_for_removal = false
        end
    end

    def op_obj(xabspos, yabspos, arg3, arg4, arg5, objname)
        if objname != (@gfx[:obj].name rescue nil)
            @gfx[:obj] = WillPlusDisplayable.new(objname, xabspos, yabspos)
            @gfx[:obj_redraw] = true
        else
            @gfx[:obj].pending_for_removal = false
        end
    end

    def op_em(emname)
        @gfx[:em] = "#{emname}"
        @rpy.add_cmd("$ side_image_override = \"Chip/#{@gfx[:em].upcase()}.png\"")
    end

    def op_hide_em()
        @rpy.add_cmd("$ side_image_override = None")
        @gfx[:em] = nil
    end

    #0x21
    def op_bgm(repeat, fadein, arg3, filename)
        cmd = "play music \"Bgm/#{filename}.OGG\""
        cmd << " fadein #{fadein / 1000.0}" if fadein != 0
        # The BGM seems to loop even if repeat is 1?
        #case repeat
        #when 0
        #    cmd << " loop"
        #when 1
        #    cmd << " noloop"
        #else
        #    cmd << " loop \# #{repeat} loops"
        #end
        cmd << ' loop'
        @rpy.add_cmd(cmd)
    end

    def op_bgm_stop(arg1, fadeout)
        cmd = "stop music"
        cmd << " fadeout #{fadeout / 1000.0}" if fadeout != 0
        @rpy.add_cmd(cmd)
    end

    def op_se(channel, repeat, is_blocking, offset, fadein, volume, filename)
        cmd = 'play '
        ch_name = 'sound'
        if channel != 0
            ch_name << "#{channel + 1}"
            @rpy.add_cmd("\# [patch:sound_channel.rpy] renpy.music.register_channel('#{ch_name}', 'sfx', False)")
        end
        cmd << ch_name << " \"Se/#{filename}\""
        cmd << " fadein #{fadein / 1000.0}" if fadein != 0
        if repeat == 255 # Loop "forever"
            cmd << ' loop'
        elsif repeat != 0
            cmd << " loop \# #{repeat} loops"
        end
        @rpy.add_cmd(cmd)
    end

    def op_se_stop(channel)
        cmd = 'stop '
        ch_name = 'sound'
        if channel != 0
            ch_name << "#{channel + 1}"
            @rpy.add_comment("[patch:sound_channel.rpy] renpy.music.register_channel('#{ch_name}', 'sfx', False)")
        end
        cmd << ch_name
        @rpy.add_cmd(cmd)
    end

    def op_voice(ch,arg2,arg3,type,arg5,filename)
        @rpy.add_cmd("voice \"Voice/#{filename}.OGG\"")
    end

    def _add_say(id, text, name=nil)
        text.encode!('utf-8', RIO_TEXT_ENCODING)
        text = _convert_escape_sequences(text)
        if name.nil?
            @rpy.add_cmd("\"#{text}\"")
        else
            name.encode!('utf-8', RIO_TEXT_ENCODING)
            chara_sym = CHARACTER_TABLE.key(name)
            if CHARACTER_TABLE_LOOKUP and chara_sym
                @rpy.add_cmd("#{chara_sym} \"#{text}\"")
            else
                @rpy.add_cmd("\"#{name}\" \"#{text}\"")
            end
        end
    end

    #0x41
    def op_text_n(id, text)
        if @say_for_menu.nil? or @say_for_menu[2] != id
            _add_say(id, text)
        else
            @rpy.add_comment("[say] Added under the next menu.")
        end
    end

    def op__option_text_n(id, text)
        _add_say(id, text)
    end

    #0x42
    def op_text_c(id, name, text)
        if @say_for_menu.nil? or @say_for_menu[2] != id
            _add_say(id, text, name)
        else
            @rpy.add_comment("[say] Added under the next menu.")
        end
    end

    def op__option_text_c(id, name, text)
        _add_say(id, text, name)
    end

    #0x54
    def op_set_trans_mask(filename)
        @gfx[:trans_mask] = filename
        @rpy.add_comment("[gfx] trans_mask = #{filename}")
    end

    def op_transition(type, duration)
        flush_gfx()
        # "none" with 0 ms time on willplus engine will at least persist the object 1 frame. Used for strobe effect in some cases.
        duration_s = [duration / 1000.0, 0.016].max
        case type #TODO
        when 'none'
            @rpy.add_cmd("with Pause(#{duration_s})")
        when 'fade_out'
            @rpy.add_cmd("with Dissolve(#{duration_s})")
        when 'fade_in'
            @rpy.add_cmd("with Dissolve(#{duration_s})")
        when 'mask'
            @rpy.add_cmd("with ImageDissolve(\"Chip/#{@gfx[:trans_mask]}.png\", #{duration_s}, 256, reverse=True)")
        when 'mask_r'
            @rpy.add_cmd("with ImageDissolve(\"Chip/#{@gfx[:trans_mask]}.png\", #{duration_s}, 256)")
        when 'mask_blend'
            @rpy.add_cmd("with ImageDissolve(\"Chip/#{@gfx[:trans_mask]}.png\", #{duration_s}, 256, reverse=True)")
        when 'mask_blend_r'
            @rpy.add_cmd("with ImageDissolve(\"Chip/#{@gfx[:trans_mask]}.png\", #{duration_s}, 256)")
        else
            @rpy.add_comment("[warning:transition] unknown method #{type}, time: #{duration_s}. Substitute with dissolve.")
            @rpy.add_cmd("with Dissolve(#{duration_s})")
        end
    end

    def op_animation_add_key_frame(index, delta_x, delta_y, ms, arg5, alpha)
        if HACK_DETECT_ANIMATION_SKIP
            bb = @cfg.inside_bb(@offset)
            if bb.jumped_from.length == 0 and bb.entry == 0
                # Unconditional animation, proceed unconditionally
            elsif bb.jumped_from.length == 0 and bb.entry != 0
                # Something is wrong, log and stop
                @rpy.add_comment("[warning:animation] Potential broken bb: back reference table has no entry and the bb is not a start block.")
                return
            elsif bb.jumped_from.length != 0 and bb.entry == 0
                # Something is wrong, log and stop
                @rpy.add_comment("[warning:animation] Potential broken bb: back reference table has entries but the bb is a start block.")
                return
            elsif bb.jumped_from.length == 1
                # Resolve the predecessor block
                pred = @cfg.get_bb_by_offset(bb.jumped_from[0])
                if pred.type == 'cjmp'
                    cond = @scr[@scr_inst_by_offset[pred.exit] - 1]
                    if ['jbe', 'jle', 'jeq', 'jne', 'jbt', 'jlt'].include?(cond[1])
                        flag_name = FLAG_TABLE[cond[2]][0] rescue nil
                        value = cond[3]
                        unless flag_name == 'skipping'
                            @rpy.add_comment("[animation] Ignoring unknown conditioned animation")
                            return
                        end
                        unless value == 0
                            @rpy.add_comment("[animation] Ignoring skip-only animation")
                            return
                        end
                    else
                        @rpy.add_comment("[warning:animation] Potential broken bb: CJMP block does not end with a CJMP instruction.")
                        return
                    end
                else
                    @rpy.add_comment("[unimplemented:animation] bb's predecessor is not a CJMP block")
                    return
                end
            else
                # TODO what about unconditional bbs that are behind an if...else? Should we traverse back to the origin?
                @rpy.add_comment("[unimplemented:animation] Multiple predecessor found for this bb.")
                return
            end
        end
        if index == 0
            @gfx[:bg].add_key_frame(delta_x, delta_y, ms, alpha)
            @gfx[:bg_redraw] = true
        else
            @gfx[:fg][index-1].add_key_frame(delta_x, delta_y, ms, alpha)
            @gfx[:fg_redraw] = true
        end
    end

    def op_play_animation(skippable)
        flush_gfx()
    end

    # TODO graphic_fx
    # graphic_fx(1, 2, 6) screen shake

    # 0x82 TODO
    def op_sleep(ms)
        @rpy.add_cmd("pause #{ms / 1000.0}")
    end

    def op_goto(scr)
        @rpy.add_cmd("jump RIO_#{scr}")
    end

    def op_eof()
        # pass
    end

    def op_video(unskippable, videofile)
        @rpy.add_cmd("$ renpy.movie_cutscene('Videos/#{videofile}')")
    end

    # TODO Figure out where fg is located (Looks like layer1 and kani.pl says it's layer1 as well but vnvm said it's on layer2. Can we trust vnvm?)
    def op_layer1_cl(index)
        @rpy.add_comment("[layer1] cl #{index}")
        unless @gfx[:fg][index].nil?
            # Flag for hiding
            @gfx[:fg][index].pending_for_removal = true
            @gfx[:fg_redraw] = true
        end
    end

    def op_obj_cl(arg1)
        @rpy.add_comment("[obj] cl")
        unless @gfx[:obj].nil?
            # Flag for hiding
            @gfx[:obj].pending_for_removal = true
            @gfx[:obj_redraw] = true
        end
    end

    def flush_gfx()
        bg_redrew = @gfx[:bg_redraw]
        if @gfx[:bg_redraw]
            unless @gfx[:bg].nil?
                atl = @gfx[:bg].to_renpy_atl()
                if atl.length != 0
                    @rpy.add_cmd("scene bg #{@gfx[:bg].name}:")
                    @rpy.begin_block()
                    atl.each { |line| @rpy.add_cmd(line) }
                    @rpy.end_block()
                else
                    @rpy.add_cmd("scene bg #{@gfx[:bg].name}")
                end
            end
            @gfx[:bg_redraw] = false
        end
        
        if @gfx[:fg_redraw]
            @gfx[:fg].each_with_index do |f, i|
                if (not f.nil?) and (not f.pending_for_removal)
                    atl = f.to_renpy_atl()
                    if atl.length == 0
                        @rpy.add_cmd("show fg #{f.name} as fg_i#{i}")
                    else
                        @rpy.add_cmd("show fg #{f.name} as fg_i#{i}:")
                        @rpy.begin_block()
                        atl.each { |line| @rpy.add_cmd(line) }
                        @rpy.end_block()
                    end
                elsif (not f.nil?) and f.pending_for_removal
                    # If the layer was flagged for hiding, hide and free the object.
                    @rpy.add_cmd("hide fg_i#{i}") unless bg_redrew
                    @gfx[:fg][i] = nil
                end
            end
            @gfx[:fg_redraw] = false
        end
        if @gfx[:obj_redraw]
            if (not @gfx[:obj].nil?) and (not @gfx[:obj].pending_for_removal)
                atl = @gfx[:obj].to_renpy_atl()
                if atl.length == 0
                    @rpy.add_cmd("show obj #{@gfx[:obj].name} as obj_i0")
                else
                    @rpy.add_cmd("show obj #{@gfx[:obj].name} as obj_i0:")
                    @rpy.begin_block()
                    atl.each { |line| @rpy.add_cmd(line) }
                    @rpy.end_block()
                end
            elsif (not @gfx[:obj].nil?) and @gfx[:obj].pending_for_removal
                # If the layer was flagged for hiding, hide and free the object.
                @rpy.add_cmd("hide obj_i0") unless bg_redrew
                @gfx[:obj] = nil
            end
            @gfx[:obj_redraw] = false
        end
    end

    def debug(message)
        STDERR.write("#{message}\n")
    end
end

class RpyGenerator
    def initialize(indent_char=nil)
        #@script = ''
        @script = []
        @indent = 0
        @indent_char = (indent_char.nil?) ? '  ' : indent_char
        @empty_block = []
    end

    def add_line(*lines)
        lines.each do |line|
            @script << {:type => :line, :indent => @indent, :payload => line}
        end
    end

    def add_cmd(*lines)
        add_line(*lines)
        @empty_block[-1] = false if @indent > 0
    end

    def add_comment(*lines)
        lines.each do |line|
            add_line("\# #{line}")
        end
    end

    def begin_block()
        @indent += 1
        @empty_block << true
    end

    def end_block()
        # TODO broken when there is only empty sub-emitters. Do we need to force a sub-emitter per block?
        add_cmd('pass') if @empty_block.pop() == true
        @indent -= 1
    end

    def insert_sub_generator()
        @script << {:type => :subgen, :indent => @indent, :payload => RpyGenerator.new(indent_char)}
    end

    def each_line()
        @script.each do |entry|
            indent_str = @indent_char * entry[:indent]
            case entry[:type]
            when :subgen
                entry[:payload].each_line { |l| yield "#{indent_str}#{l}" }
            when :line
                yield "#{indent_str}#{entry[:payload]}"
            end
        end
    end

    def empty?()
        return @script.empty?
    end

    def to_s()
        # TODO this is super hacky. Find a better way to do this
        return to_enum(:each_line).to_a.join("\n")
    end
end

include RIOASMTranslator

abort("Usage: #{$PROGRAM_NAME} scr rpy") if ARGV.length < 2
File.open(ARGV[1], 'w') do |f|
    f.write(translate(File.basename(ARGV[0]).split('.')[0], RIOOpCode.decode_script(IO.binread(ARGV[0]), true)))
end
